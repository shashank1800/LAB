// Bresenham Line Drawing Algorithm
#include<stdio.h>
#include<math.h>
#include<glut.h>

int xStart, yStart, xEnd, yEnd;

void myInit()
{
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	gluOrtho2D(0, 500, 0, 500);
	glMatrixMode(GL_MODELVIEW);
}

void setPixel(int x, int y)
{
	glBegin(GL_POINTS);
	glVertex2f(x, y);
	glEnd();
	glFlush();
}

void bresenhamLine(int x1, int y1, int x2, int y2)
{
	if (abs(y2 - y1) < abs(x2 - x1))
	{
		if (x1 > x2)
			drawLineLow(x2, y2, x1, y1);
		else
			drawLineLow(x1, y1, x2, y2);
	}
	else
	{
		if (y1 > y2)
			drawLineHigh(x2, y2, x1, y1);
		else
			drawLineHigh(x1, y1, x2, y2);
	}
}
void drawLineLow(int x1, int y1, int x2, int y2)
{
	int dx = x2 - x1;
	int dy = y2 - y1;
	int iy = 1;

	if (dy < 0)
	{
		iy = -1;
		dy = -dy;
	}
	int P = 2 * dy - dx;
	int y = y1;


	for (int x = x1; x <= x2; x++)
	{
		setPixel(x, y);
		if (P > 0)
		{
			y = y + iy;
			P = P - 2 * dx;
		}
		P = P + 2 * dy;
	}
}

void drawLineHigh(int x1, int y1, int x2, int y2)
{
	int dx = x2 - x1;
	int dy = y2 - y1;
	int ix = 1;

	if (dx < 0)
	{
		ix = -1;
		dx = -dx;
	}

	int P = 2 * dx - dy;

	int x = x1;

	for (int y = y1; y <= y2; y++)
	{
		setPixel(x, y);
		if (P > 0)
		{
			x = x + ix;
			P = P - 2 * dy;
		}
		P = P + 2 * dx;
	}
}

void display()
{

	glClearColor(1, 1, 1, 1);
	glClear(GL_COLOR_BUFFER_BIT);
	glColor3f(1, 0, 0);
	glPointSize(2);
	bresenhamLine(xStart, yStart, xEnd, yEnd);
	glFlush();
}





int main()
{
	glutInitDisplayMode(GLUT_RGB | GLUT_SINGLE);
	glutInitWindowPosition(100, 100);
	glutInitWindowSize(500, 500);
	glutCreateWindow("Bresenham's Line Drawing Algorthm");
	myInit();

	printf("Enter co-ordinates of first point: ");
	scanf_s("%d %d", &xStart, &yStart);

	printf("Enter co-ordinates of second point: ");
	scanf_s("%d %d", &xEnd, &yEnd);

	glutDisplayFunc(display);
	glutMainLoop();
}






































// Sierpinski Gasket
#include<stdio.h>
#include<math.h>
#include<glut.h>

struct Point
{
	float x, y, z;
	Point()
	{x = y = z = 0;}

	Point(float x, float y, float z)
	{
		this->x = x;
		this->y = y;
		this->z = z;
	}
};

int n;
Point points[4] = { Point(0,1,0), Point(0.5,-0.5,0), Point(-0.5,-0.5,0), Point(0,0,1) };

void myInit()
{
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	glOrtho(-2, 2, -2, 2, -2, 2);
	glMatrixMode(GL_MODELVIEW);
}

void drawTriangle(Point a, Point b, Point c)
{
	glBegin(GL_POLYGON);
	glVertex3f(a.x, a.y, a.z);
	glVertex3f(b.x, b.y, b.z);
	glVertex3f(c.x, c.y, c.z);
	glEnd();
}

void divideTriangle(Point a, Point b, Point c, int n)
{
	if (n > 0)
	{
		Point midAB = midPoint(a, b);
		Point midBC = midPoint(b, c);
		Point midCA = midPoint(c, a);

		divideTriangle(a, midAB, midCA, n - 1);
		divideTriangle(midAB, b, midBC, n - 1);
		divideTriangle(midCA, midBC, c, n - 1);
	}

	else
		drawTriangle(a, b, c);
}

Point midPoint(Point a, Point b)
{
	Point mid;
	mid.x = (a.x + b.x) / 2;
	mid.y = (a.y + b.y) / 2;
	mid.z = (a.z + b.z) / 2;
	return mid;
}

void display()
{

	glClearColor(1, 1, 1, 1);
	glClear(GL_COLOR_BUFFER_BIT);
	glColor3f(1, 0, 0);
	divideTriangle(points[0], points[1], points[2], n);
	glColor3f(0, 1, 0);
	divideTriangle(points[3], points[2], points[0], n);
	glColor3f(0, 0, 1);
	divideTriangle(points[3], points[0], points[1], n);
	glColor3f(1, 0, 1);
	divideTriangle(points[3], points[1], points[2], n);
	glFlush();
}

int main()
{
	glutInitDisplayMode(GLUT_RGB | GLUT_SINGLE);
	glutInitWindowPosition(100, 100);
	glutInitWindowSize(500, 500);
	glutCreateWindow("3D SIERPINSKI PATTERN");
	printf("Enter the value of n: ");
	scanf_s("%d", &n);
	myInit();
	glutDisplayFunc(display);
	glutMainLoop();
}

















// Scan fill Program
#include<glut.h>
#include<stdio.h>

void myinit()
{
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	gluOrtho2D(0, 500,0, 500);
	glColor3f(1, 1, 0);
	glMatrixMode(GL_MODELVIEW);
}

void drawpixel(int x, int y) {
	glBegin(GL_POINTS);
	glVertex2f(x, y);
	glEnd();
	glFlush();
}

void edgedetect(float x1, float y1, float x2, float y2, int *le, int *re)
{
	float mx, temp;
	int i;
	if ((y2 - y1) < 0) {
		temp = y1;
		y1 = y2;
		y2 = temp;
		temp = x1;
		x1 = x2;
		x2 = temp;
	}
	mx = (x2 - x1) / (y2 - y1);
	float x = x1;
	for (i = y1; i <= y2; i++) {
		if (x < (float)le[i])
			le[i] = (int)x;
		if (x > (float)re[i])
			re[i] = (int)x;
		x += mx;
	}
}

void scanfill1(float x1, float y1, float  x2, float  y2, float  x3, float  y3, float  x4, float y4)
{
	int le[500], re[500];
	for (int i = 0; i < 500; i++) {
		le[i] = 500;
		re[i] = 0;
	}
	edgedetect(x1, y1, x2, y2, le, re);
	edgedetect(x2, y2, x3, y3, le, re);
	edgedetect(x3, y3, x4, y4, le, re);
	edgedetect(x4, y4, x1, y1, le, re);
	
for (int y = 0; y <= 500; y++) {
		if (le[y] <= re[y])
			for (int i = (int)le[y]; i < (int)re[y]; i++)
				drawpixel(i, y);
	}
}

void dmenu(int op) {
	if (op == 1)
		glColor3f(1, 0, 0);
	else if (op == 2)
		glColor3f(0, 0, 1);
	else if (op == 3)
		glColor3f(0, 1, 0);
	else if (op == 4)
		exit(0);
	glutPostRedisplay();
}

void display()
{
	float x1 = 200, y1 = 200, x2 = 100, y2 = 300;
	float x3 = 200, y3 = 400, x4 = 300, y4 = 300;
	glClear(GL_COLOR_BUFFER_BIT);

	glLineWidth(8);
	glBegin(GL_LINE_LOOP);
	glVertex2f(x1, y1);
	
	glVertex2f(x2, y2);
	glColor3f(0, 1, 1);
	glVertex2f(x3, y3);
	glColor3f(0, 1, 0);
	glVertex2f(x4, y4);
      glColor3f(0, 0, 1);
	glEnd();
	glFlush();
	scanfill1(x1, y1, x2, y2, x3, y3, x4, y4);
}

int main() {
	glutInitDisplayMode(GLUT_RGB | GLUT_SINGLE);
	glutInitWindowSize(500, 500);
	glutInitWindowPosition(350, 350);
	glutCreateWindow("Scan fill Program");
	myinit();
	glutCreateMenu(dmenu);
	glutAddMenuEntry("red", 1);
	glutAddMenuEntry("bule", 2);
	glutAddMenuEntry("green", 3);
	glutAddMenuEntry("quit", 4);
	glutAttachMenu(GLUT_RIGHT_BUTTON);
	glutDisplayFunc(display);
	glutMainLoop();
}
