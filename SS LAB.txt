1.a. Write a LEX program to recognize valid arithmetic expression. Identifiers in the
expression could be only integers and operators could be + and *. Count the
identifiers & operators present and print them separately.

%{
    int opnd = 0, ac = 0, sc = 0, mc = 0, dc = 0, valid = 0;
    void ext();
%}

%x OPER
%%

[a-zA-Z0-9]+ {valid = 1; opnd++; BEGIN OPER;}
<OPER>"+" {if(valid == 1) {valid = 0; ac++;} else {ext();}}
<OPER>"-" {if(valid == 1) {valid = 0; sc++;} else {ext();}}
<OPER>"*" {if(valid == 1) {valid = 0; mc++;} else {ext();}}
<OPER>"/" {if(valid == 1) {valid = 0; dc++;} else {ext();}}
<OPER>[a-zA-Z0-9]+ {if (valid == 0) {valid = 1; opnd++;} else {ext();}}
<OPER>. ext();
<OPER>\n return 0;
. ext();
\n return 0;

%%

void ext()
{
    printf("Invalid Expression");
    exit(0);
}
void main()
{
    printf("Enter Expression\n");
    yylex();
    printf("Valid Expression\n");
    printf("Count Operand=%d, Plus=%d, Minus=%d, Multiply=%d, Divide=%d\n", opnd, ac, sc, mc, dc);
}

Output:
>>> lex 01.a.Identify_Expression.l 
>>> gcc lex.yy.c -ll
>>> ./a.out 
Enter Expression
a+b*c
Valid Expression
Count Operand=3, Plus=1, Minus=0, Multiply=1, Divide=0
-----------------------------------------------------------------------------------------------------

1.b. Write YACC program to evaluate arithmetic expression involving operators: +, -, *, and /

LEX Part

%{
    #include "y.tab.h"
    extern int yylval;
%}

%%

[0-9]+ {yylval = atoi(yytext); return NUM;}
[+\-*/] return yytext[0];
. return yytext[0];
\n return 0;

%%

YACC Part

%{
    #include <stdio.h>
    #include <stdlib.h>
    int yylex();
    int yyerror();
%}

%left '+' '-'
%left '*' '/'
%token NUM

%%

expr: stmt {printf("Result=%d\n", $1);}
    ;
stmt: stmt '+' stmt {$$ = $1 + $3;}
    | stmt '-' stmt {$$ = $1 - $3;}
    | stmt '*' stmt {$$ = $1 * $3;}
    | stmt '/' stmt {if($3 != 0) {$$ = $1 / $3;} else {yyerror();}}
    | NUM {$$ = $1;}
    ;

%%
void main()
{
    if(yyparse() == 0)
    {
        // Do Nothing, Result is already printed
    }
    else
    {
        yyerror();
    }
}
int yyerror()
{
    printf("Invalid Expression\n");
    exit(0);
}

Output:
>>> lex 01.b.01.Evaluate_Expression_Lex.l 
>>> yacc -d 01.b.02.Evaluate_Expression_Yacc.y 
>>> gcc lex.yy.c y.tab.c -ll -ly
>>> ./a.out 
2+3*8
Result=26
-----------------------------------------------------------------------------------------------------

2. Develop, Implement and Execute a program using YACC tool to recognize all strings
ending with b preceded by n a’s using the grammar a
n b (note: input n value)

LEX Part

%{
    #include "y.tab.h"
%}

%%

a return A;
b return B;
. return yytext[0];
\n return 0;

%%

YACC Part

%{
    #include <stdio.h>
    #include <stdlib.h>
    int count=0;
    int yylex();
    int yyerror();
%}

%token A B
%%

str: T B
    ;
T: A T {++count;}
    |
    ;

%%
void main()
{
    int n;
    printf("Enter n value\n");
    scanf("%d\n", &n);
    if(yyparse() == 0 && n == count)
    {
        printf("Valid String\n");
    }
    else
    {
        yyerror();
    }
}
int yyerror()
{
    printf("Invalid String\n");
}

Output:
>>> lex 02.01.Recognize_AnB_Lex.l 
>>> yacc -d 02.02.Recognize_AnB_Yacc.y 
>>> gcc lex.yy.c y.tab.c -ll -ly
>>> ./a.out 
Enter n value
5
aaaaab
Valid String
-----------------------------------------------------------------------------------------------------

3. Design, develop and implement YACC/C program to construct Predictive / LL(1)
Parsing Table for the grammar rules: A ?aBa , B ?bB | e. Use this table to parse
the sentence: abba$

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

char prod[3][10] = {"A->aBa", "B->bB", "B->@"};
char first[3][10] = {"a", "b", "@"};
char follow[3][10] = {"$", "a", "a"};
char table[3][4][10];
char input[10];
int top=-1;
char stack[25];
char curp[20];

void push(char item)
{
    stack[++top] = item;
}

void pop()
{
    top -= 1;
}

void display()
{
    int i;
    for(i = top; i>=0; i--)
        printf("%c", stack[i]);
}

int numr(char c)
{
    switch(c)
    {
        case 'A':
        case 'a':
                return 1;
        case 'B':
        case 'b':
                return 2;
        case '$':
                return 3;
    }
    return 1;
}

void main()
{
    char c;
    int i, j, k, n;
    for(i = 0; i<3; i++)
    {
        for(j = 0; j<4; j++)
        {
            strcpy(table[i][j], "e");
        }
    }
    
    printf("Grammar:\n");
    for(i=0; i<3; i++)
        printf("%s\n\n", prod[i]);
    
    printf("first={%s, %s, %s}\n", first[0], first[1], first[2]);
    printf("follow={%s, %s}\n", follow[0], follow[1]);
    
    strcpy(table[0][0], " ");
    strcpy(table[0][1], "a");
    strcpy(table[0][2], "b");
    strcpy(table[0][3], "$");
    strcpy(table[1][0], "A");
    strcpy(table[2][0], "B");
    
    for(i=0; i<3; i++)
    {
        if(first[i][0] != '@')
            strcpy(table[numr(prod[i][0])][numr(first[i][0])], prod[i]);
        else
            strcpy(table[numr(prod[i][0])][numr(follow[i][0])], prod[i]);
    }
    
    printf("Enter the input string\n");
    scanf("%s", input);
    
    for(i=0; input[i] != '\0'; i++)
    {
        if(input[i] != 'a' && input[i] != 'b'&& input[i] != '$')
        {
            printf("Invalid String\n");
            exit(0);
        }
    }
    
    if(input[i-1] != '$')
    {
        printf("No End Pointer\n");
        exit(0);
    }
    
    push('$');
    push('A');
    
    i=0;
    printf("\n\n");
    printf("Stack\t\tInput\t\tAction\n");
    while(input[i] != '$' && stack[top] != '$')
    {
        display();
        printf("\t\t%s\t", (input+i));
        if(stack[top] == input[i])
        {
            printf("\tMatched %c\n", input[i]);
            pop();
            i++;
        }
        else
        {
            if(stack[top]>=65 && stack[top] <92)
            {
                strcpy(curp, table[numr(stack[top])][numr(input[i])]);
                if(!strcmp(curp, "e"))
                {
                    printf("Invalid");
                    exit(0);
                }
                else
                {
                    printf("\tApply Production %s\n", curp);
                    if(curp[3] == '@')
                        pop();
                    else
                    {
                        pop();
                        n = strlen(curp);
                        for(j=n-1; j>=3; j--)
                            push(curp[j]);
                    }
                }
            }
        }
    }
    
    display();
    printf("\t\t%s\t\n", (input+i));
    if(stack[top] == '$' && input[i] == '$')
    {
        printf("Valid String\n");
    }
    else
    {
        printf("Invalid String\n");
    }
}

Output:
>>> gcc 03.LL1_Parser.c 
>>> ./a.out 

Grammar:
A->aBa
B->bB
B->@
first={a, b, @}
follow={$, a}
Enter the input string
abba$
Stack		Input		Action
A$		abba$		Apply Production A->aBa
aBa$		abba$		Matched a
Ba$		bba$		Apply Production B->bB
bBa$		bba$		Matched b
Ba$		ba$		Apply Production B->bB
bBa$		ba$		Matched b
Ba$		a$		Apply Production B->@
a$		a$		Matched a
$		$	
Valid String
-----------------------------------------------------------------------------------------------------
4. Design, develop and implement YACC/C program to demonstrate Shift Reduce
Parsing technique for the grammar rules: E →E+T | T, T →T*F | F, F →(E) | id
and parse the sentence: id + id * id. 

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
char ip_sym[15], stack[15];
int ip_ptr = 0, st_ptr = 0, len, i;
char temp[3];
char act[15];
void check();
void main()
{
    printf("Grammar\n");
    printf("E -> E + T | T\n");
    printf("T -> T * F | F\n");
    printf("F -> (E) | id \n");
    printf("Enter the input expression:\n");
    scanf("%s", ip_sym);
    printf("Stack\t\t\tInput Dymbol\t\t\tAction\n");
    printf("$\t\t\t%s$\t\t\t--\n", ip_sym);
    strcpy(act, "Shift ");
    if (ip_sym[ip_ptr] == '(')
    {
        temp[0] = ip_sym[ip_ptr];
        temp[1] = '\0';
    }
    else
    {
        temp[0] = ip_sym[ip_ptr];
        temp[1] = ip_sym[ip_ptr + 1];
        temp[2] = '\0';
    }
    strcat(act, temp);
    len = strlen(ip_sym);

    for (i = 0; i <= len - 1; i++)
    {
        if (ip_sym[ip_ptr] == 'i' && ip_sym[ip_ptr + 1] == 'd')
        {
            stack[st_ptr] = ip_sym[ip_ptr];
            st_ptr++;
            ip_sym[ip_ptr] = ' ';
            ip_ptr++;
            stack[st_ptr] = ip_sym[ip_ptr];
            stack[st_ptr + 1] = '\0';
            ip_sym[ip_ptr] = ' ';
            ip_ptr++;
        }
        else
        {
            stack[st_ptr] = ip_sym[ip_ptr];
            stack[st_ptr + 1] = '\0';
            ip_sym[ip_ptr] = ' ';
            ip_ptr++;
        }
        printf("$%s\t\t\t%s$\t\t\t%s\n", stack, ip_sym, act);
        strcpy(act, "Shift ");
        if (ip_sym[ip_ptr] == '(' || ip_sym[ip_ptr] == '*' || ip_sym[ip_ptr] == '+' || ip_sym[ip_ptr] == ')')
        {
            temp[0] = ip_sym[ip_ptr];
            temp[1] = '\0';
        }
        else
        {
            temp[0] = ip_sym[ip_ptr];
            temp[1] = ip_sym[ip_ptr + 1];
            temp[2] = '\0';
        }
        strcat(act, temp);
        check();
        st_ptr++;
    }
    st_ptr++;
    check();
}

void check()
{
    int flag = 0;
    while (1)
    {
        if (stack[st_ptr] == 'd' && stack[st_ptr - 1] == 'i')
        {
            stack[st_ptr - 1] = 'F';
            stack[st_ptr] = '\0';
            st_ptr--;
            flag = 1;
            printf("$%s\t\t\t%s$\t\t\tF->id\n", stack, ip_sym);
        }

        if (stack[st_ptr] == ')' && stack[st_ptr - 1] == 'E' && stack[st_ptr - 2] == '(')
        {
            stack[st_ptr - 2] = 'F';
            stack[st_ptr - 1] = '\0';
            flag = 1;
            st_ptr = st_ptr - 2;
            printf("$%s\t\t\t%s$\t\t\tF->id\n", stack, ip_sym);
        }

        if (stack[st_ptr] == 'F' && stack[st_ptr - 1] == '*' && stack[st_ptr - 2] == 'T')
        {
            stack[st_ptr - 1] = '\0';
            st_ptr = st_ptr - 2;
            flag = 1;
            printf("$%s\t\t\t%s$\t\t\tT->T*F\n", stack, ip_sym);
        }
        else if (stack[st_ptr] == 'F')
        {
            stack[st_ptr] = 'T';
            flag = 1;
            printf("$%s\t\t\t%s$\t\t\tT->F\n", stack, ip_sym);
        }

        if (stack[st_ptr] == 'T' && stack[st_ptr - 1] == '+' && stack[st_ptr - 2] == 'E' && ip_sym[ip_ptr] != '*')
        {
            stack[st_ptr - 1] = '\0';
            st_ptr = st_ptr - 2;
            flag = 1;
            printf("$%s\t\t\t%s$\t\t\tE->E+T\n", stack, ip_sym);
        }
        else if ((stack[st_ptr] == 'T' && ip_sym[ip_ptr] == '+') || (stack[0] == 'T' && ip_sym[ip_ptr] == '\0') ||
                 (stack[st_ptr] == 'T' && ip_sym[ip_ptr] == ')'))
        {
            stack[st_ptr] = 'E';
            flag = 1;
            printf("$%s\t\t\t%s$\t\t\tE->T\n", stack, ip_sym);
        }

        if (ip_sym[ip_ptr] != '$' && flag != 1)
        {
            flag = 2;
        }

        if (!strcmp(stack, "E") && ip_sym[ip_ptr] == '\0')
        {
            printf("$%s\t\t\t%s$\t\t\tAccept\n", stack, ip_sym);
            exit(0);
        }

        if (flag == 0)
        {
            printf("\n%s\t\t\t%s\t\tReject", stack, ip_sym);
            exit(0);
        }

        if (flag == 2)
        {
            return;
        }

        flag = 0;
    }
}


Output:
Grammar
E -> E + T | T
T -> T * F | F
F -> (E) | id 
Enter the input expression:
id+id*id
Stack			Input Dymbol		Action
$			    id+id*id$			--
$id			      +id*id$			Shift id
$F			      +id*id$			F->id
$T			      +id*id$			T->F
$E			      +id*id$			E->T
$E+			       id*id$			Shift +
$E+id			     *id$			Shift id
$E+F			     *id$			F->id
$E+T			     *id$			T->F
$E+T*			      id$			Shift *
$E+T*id			        $			Shift id
$E+T*F			        $			F->id
$E+T			        $			T->T*F
$E			            $			E->E+T
$E			            $			Accept
------------------------------------------------------------------------------------------------

5. Design, develop and implement a C/Java program to generate the machine code using triples for the statement A = -B * (C +D) whose intermediate code in three-address form: 
    T1 = -B 
    T2 = C + D 
    T3 = T1 + T2 
    A = T3

#include <stdio.h>
#include <stdio.h>
#include <string.h>
void main()
{
    char icode[10][30], opr;
    char op1[5], op2[5], res[5];
    int i = 0, n, j, k;
    printf("\nenter the number of intermediate statements");
    scanf("%d", &n);
    printf("\n Enter the set of intermediate code \n");
    for (i = 0; i < n; i++)
    {
        scanf("%s", icode[i]);
    }
    printf("\n");
    for (i = 0; i < n; i++)
    {
        j = 0, k = 0;
        while (icode[i][j] != '=')
        {
            res[k] = icode[i][j];
            j = j + 1;
            k = k + 1;
        }
        res[j] = '\0';
        k = 0;
        j++;
        if (icode[i][j] == '-')
        {
            j++;
            while (icode[i][j] != '\0')
            {
                op1[k] = icode[i][j];
                j++;
                k++;
            }
            op1[k] = '\0';
            printf("\nLoad R1,%s \n", op1);
            printf("NEG R1\n");
            printf("STORE %s,R1\n", res);
        }
        else
        {
            k = 0;
            while (icode[i][j] != '\0' && icode[i][j] != '+' && icode[i][j] != '-')
            {
                op1[k] = icode[i][j];
                j++;
                k++;
            }
            op1[k] = '\0';
            if (icode[i][j] == '\0')
            {
                printf("\nLoad R4,%s \n", op1);
                printf("STORE %s,R4\n", res);
                continue;
            }
            else
            {
                opr = icode[i][j];
                k = 0;
                j++;
                while (icode[i][j] != '\0')
                {
                    op2[k] = icode[i][j];
                    j++;
                    k++;
                }
                op2[k] = '\0';
            }
            switch (opr)
            {
            case '+':
                printf("Load R2,%s \n", op1);
                printf("Load R3,%s \n", op2);
                printf("ADD R1,R2,R3\n");
                printf("STORE %s,R1\n", res);
                break;
            case '-':
                printf("Load R2,%s \n", op1);
                printf("Load R3,%s \n", op2);
                printf("SUB R1,R3,R2\n");
                printf("STORE %s,R1\n", res);
            default:
                printf("\n Invalid statement\n");
            }
        }
    }
}

